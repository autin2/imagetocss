<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Image → CSS</title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body class="is-app">
  <div class="container" style="padding-top:24px;padding-bottom:24px">
    <h1>Image → CSS</h1>
    <p class="lead">Upload/paste a <b>cropped screenshot of one component</b> (button, card, input). We’ll generate scoped CSS with GPT-5.</p>

    <div class="app-grid">
      <!-- LEFT: fixed-height panel -->
      <section class="card app-panel pad">
        <div class="snip-frame drop" id="drop" tabindex="0" aria-label="Drop or choose an image">
          <!-- Empty state -->
          <div class="drop-inner" id="emptyUi">
            <div>
              <div><b>Drop an image</b>, click <em>Choose</em>, or paste (Ctrl/Cmd+V).</div>
              <div class="btn-row" style="margin-top:8px">
                <button id="chooseBtn" class="btn small">Choose</button>
                <button id="pasteBtn" class="btn small">Paste</button>
              </div>
              <div class="hint" id="sizeHint">No image selected</div>
            </div>
          </div>

          <!-- Image lives inside the frame -->
          <img id="preview" class="preview-img" alt="Selected image preview"/>

          <!-- Hover overlay (only when image selected) -->
          <div class="overlay" id="overlay">
            <button id="changeBtn" class="btn accent">Change photo</button>
          </div>

          <!-- hidden input -->
          <input id="file" type="file" accept="image/*" hidden>
        </div>

        <!-- Inputs (palette removed) -->
        <div class="grid-2" style="gap:12px; margin-top:14px">
          <div>
            <div class="lead" style="font-size:13px;margin:0 0 6px;color:var(--muted);font-weight:700">Scope class</div>
            <input id="scope" type="text" class="input" value=".comp" placeholder=".comp" style="width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border)"/>
          </div>
          <div>
            <div class="lead" style="font-size:13px;margin:0 0 6px;color:var(--muted);font-weight:700">Component hint</div>
            <input id="component" type="text" class="input" value="button" placeholder="button, card, input, …" style="width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border)"/>
          </div>
        </div>

        <!-- Controls row (one line, aligned) -->
        <div class="controls" style="margin-top:12px">
          <button id="runBtn" class="btn primary">Generate CSS</button>
          <button id="clearBtn" class="btn">Clear</button>
          <span id="statusLead" class="lead spacer" style="font-size:13px;color:var(--muted)"></span>
          <span class="api-pill">API: <b id="apiStatus">—</b></span>
        </div>
      </section>

      <!-- RIGHT: fixed-height panel with internal scrolling -->
      <section class="card app-panel pad">
        <div class="outputbar">
          <span class="label">Final CSS</span>
          <button id="copyFinalBtn" class="btn small">Copy</button>
        </div>
        <pre id="output" class="code" aria-label="Final CSS"></pre>

        <div class="outputbar" style="margin-top:8px">
          <span class="label">API response / errors</span>
        </div>
        <pre id="errors" class="code" aria-label="Errors"></pre>
      </section>
    </div>
  </div>

  <!-- Global loading overlay -->
  <div id="loading" class="loading-scrim" aria-hidden="true">
    <div class="loading-card" role="status" aria-live="polite" aria-atomic="true">
      <span class="spinner" aria-hidden="true"></span>
      <div>
        <div class="loading-title">Generating CSS…</div>
        <div class="loading-sub">This usually takes a few seconds.</div>
      </div>
    </div>
  </div>

  <script>
    // ----- Elements -----
    const fileEl = document.getElementById('file');
    const dropEl = document.getElementById('drop');
    const chooseBtn = document.getElementById('chooseBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const changeBtn = document.getElementById('changeBtn');
    const sizeHint = document.getElementById('sizeHint');
    const preview = document.getElementById('preview');

    const scopeEl = document.getElementById('scope');
    const componentEl = document.getElementById('component');

    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
    const statusLead = document.getElementById('statusLead');
    const apiStatus = document.getElementById('apiStatus');

    const outputEl = document.getElementById('output');
    const errorsEl = document.getElementById('errors');
    const copyFinalBtn = document.getElementById('copyFinalBtn');

    const loading = document.getElementById('loading');

    let dataUrl = "";

    // ----- Loading overlay -----
    function setLoading(on){
      loading.classList.toggle('open', !!on);
      loading.setAttribute('aria-hidden', on ? 'false' : 'true');
    }

    // ----- DnD / Choose / Paste -----
    chooseBtn.addEventListener('click', () => fileEl.click());
    changeBtn.addEventListener('click', () => fileEl.click());

    dropEl.addEventListener('click', (e) => {
      if (!dropEl.classList.contains('has-image') && e.target === dropEl) fileEl.click();
    });

    fileEl.addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f) readFile(f); });

    dropEl.addEventListener('dragover', (e)=>{ e.preventDefault(); dropEl.classList.add('drag'); });
    dropEl.addEventListener('dragleave', ()=> dropEl.classList.remove('drag'));
    dropEl.addEventListener('drop', (e)=>{
      e.preventDefault(); dropEl.classList.remove('drag');
      const f = e.dataTransfer.files?.[0]; if (f) readFile(f);
    });

    pasteBtn.addEventListener('click', () => {
      navigator.clipboard.read?.().then(async items => {
        for (const item of items) for (const t of item.types) {
          if (t.startsWith('image/')) { const blob = await item.getType(t); readFile(blob); return; }
        }
        flash("No image on clipboard");
      }).catch(()=> flash("Clipboard read not allowed"));
    });
    window.addEventListener('paste', (e) => {
      const it = [...(e.clipboardData?.items || [])].find(i => i.type.startsWith('image/'));
      if (it) readFile(it.getAsFile());
    });

    dropEl.addEventListener('keydown', (e)=>{
      if (!dropEl.classList.contains('has-image') && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault(); fileEl.click();
      }
    });

    function readFile(file){
      const r = new FileReader();
      r.onload = () => {
        dataUrl = r.result;
        preview.src = dataUrl;
        dropEl.classList.add('has-image');
        sizeHint.textContent = formatBytes(file.size || new Blob([dataUrl]).size);
        statusLead.textContent = "Image ready";
      };
      r.readAsDataURL(file);
    }

    function clearImage(){
      dataUrl = "";
      preview.src = "";
      dropEl.classList.remove('has-image');
      sizeHint.textContent = "No image selected";
    }

    function formatBytes(n){ if (!n && n!==0) return "0 KB"; const u=['B','KB','MB','GB']; let i=0; while(n>=1024 && i<u.length-1){n/=1024;i++} return `${n.toFixed(i?1:0)} ${u[i]}`; }
    function flash(msg){ sizeHint.textContent = msg; setTimeout(()=> sizeHint.textContent = sizeHint.textContent || msg, 1400); }

    // ----- Quick flatness detection (top vs bottom) -----
    async function isFlatImage(imgEl, threshold = 12) {
      const cnv = document.createElement('canvas');
      const ctx = cnv.getContext('2d', { willReadFrequently: true });
      cnv.width = imgEl.naturalWidth; cnv.height = imgEl.naturalHeight;
      ctx.drawImage(imgEl, 0, 0);
      const h = cnv.height, w = cnv.width;
      const x0 = Math.floor(w * 0.25), x1 = Math.floor(w * 0.75);

      function avgRowRange(y0, y1) {
        const hgt = Math.max(1, y1 - y0);
        const img = ctx.getImageData(x0, y0, x1 - x0, hgt).data;
        let r=0,g=0,b=0,count=0;
        for (let i=0;i<img.length;i+=4){ r+=img[i]; g+=img[i+1]; b+=img[i+2]; count++; }
        return [r/count, g/count, b/count];
      }
      const top = avgRowRange(0, Math.floor(h*0.25));
      const bot = avgRowRange(Math.floor(h*0.75), h);
      const dist = Math.hypot(top[0]-bot[0], top[1]-bot[1], top[2]-bot[2]);
      return { flat: dist < threshold, top, bot };
    }

    function rgbToHex([r,g,b]){
      const to = (n)=>Math.max(0,Math.min(255,Math.round(n))).toString(16).padStart(2,"0");
      return `#${to(r)}${to(g)}${to(b)}`;
    }
    function meanRGB(a,b){ return [(a[0]+b[0])/2,(a[1]+b[1])/2,(a[2]+b[2])/2]; }

    function solidifyCss(css, hexColor) {
      const solid = `background-color: ${hexColor};`;
      return css
        .replace(/background\s*:\s*[^;]*gradient\([^;]*\)\s*;?/gi, solid)
        .replace(/background-image\s*:\s*[^;]*gradient\([^;]*\)\s*;?/gi, "background-image: none;")
        .replace(/::after\s*\{[^}]*\}/gi, (block) => {
          if (/background[^;]*gradient/i.test(block) || /rgba\([^)]*,\s*[^)]*,\s*[^)]*,\s*0(\.\d+)?\)/i.test(block)) {
            return "";
          }
          return block;
        });
    }

    // ----- API helper (safe text → JSON) -----
    async function generateCSS({ image, scope = ".comp", component = "button", force_solid = false, solid_color = "" }) {
      const r = await fetch("/api/generate-css", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ image, palette: [], scope, component, force_solid, solid_color }),
      });

      const text = await r.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}

      if (!r.ok) {
        const err = new Error((json && (json.error || json.message)) || text || `HTTP ${r.status}`);
        err.status = r.status;
        err.payload = json ?? text;
        throw err;
      }
      return json ?? { error: "Malformed JSON from server", raw: text };
    }

    function fmt(x) { if (typeof x === "string") return x; try { return JSON.stringify(x, null, 2); } catch { return String(x); } }

    // ----- Actions -----
    runBtn.addEventListener('click', onRun);
    clearBtn.addEventListener('click', () => { clearOutputs(); clearImage(); });
    copyFinalBtn.addEventListener('click', async ()=> {
      if (!outputEl.textContent) return;
      try { await navigator.clipboard.writeText(outputEl.textContent); copyFlash(copyFinalBtn); } catch {}
    });

    async function onRun(){
      clearOutputs();
      if (!dataUrl || !dataUrl.startsWith('data:image')) {
        errorsEl.textContent = "Pick or paste an image first (cropped to a single component).";
        apiStatus.textContent = "400"; apiStatus.style.color = "#ef4444"; return;
      }

      try {
        runBtn.disabled = true;
        setLoading(true);
        statusLead.textContent = "Analyzing…";
        apiStatus.textContent = "…"; apiStatus.style.color = "";

        // Flatness check + color
        const { flat, top, bot } = await isFlatImage(preview, 12);
        const avgHex = rgbToHex(meanRGB(top, bot));

        statusLead.textContent = flat ? "Flat background detected" : "Gradient-like variation detected";
        const res = await generateCSS({
          image: dataUrl,
          scope: scopeEl.value || ".comp",
          component: componentEl.value || "component",
          force_solid: flat,
          solid_color: avgHex
        });

        apiStatus.textContent = "200 OK"; apiStatus.style.color = "#16a34a";
        statusLead.textContent = `Done (${res.passes} pass${res.passes===1?"":"es"})`;

        let finalCss = res.css || "";
        // Safety: if we forced solid, strip any gradient that slipped through
        if (flat && /gradient\(/i.test(finalCss)) {
          finalCss = solidifyCss(finalCss, avgHex);
        }
        outputEl.textContent = finalCss;

        if (!finalCss.trim()) {
          errorsEl.textContent = `Model raw_out (first 2k):\n` + String(res.raw_out || "").slice(0, 2000);
        } else {
          errorsEl.textContent = "";
        }
      } catch (err) {
        apiStatus.textContent = String(err.status || 500); apiStatus.style.color = "#ef4444";
        statusLead.textContent = "Error";
        const dump = [
          `Status: ${err.status ?? 'unknown'}`,
          `Message: ${fmt(err.message)}`,
          err.payload !== undefined ? `Payload:\n${fmt(err.payload)}` : ""
        ].filter(Boolean).join("\n");
        errorsEl.textContent = dump;
        console.error("API error dump:", err);
      } finally {
        setLoading(false);
        runBtn.disabled = false;
      }
    }

    function clearOutputs(){
      outputEl.textContent = ""; errorsEl.textContent = "";
      apiStatus.textContent = "—"; apiStatus.style.color = ""; statusLead.textContent = "";
    }
    function copyFlash(btn){ const prev=btn.textContent; btn.textContent="Copied!"; setTimeout(()=>btn.textContent=prev, 900); }
  </script>
</body>
</html>
